<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test Parent Survey PDF Generator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <!-- Add PDF-lib for truly fillable PDFs -->
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        .container {
            background: #f5f5f5;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            margin-right: 10px;
            margin-bottom: 10px;
        }
        button:hover {
            background: #0056b3;
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        .button-group {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background-color: #f9f9f9;
        }
        
        .button-group h3 {
            margin: 0 0 10px 0;
            color: #333;
        }
        
        .button-group button {
            margin-right: 10px;
        }
        .status {
            margin-top: 20px;
            padding: 10px;
            border-radius: 4px;
        }
        .success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        .survey-info {
            background: white;
            padding: 15px;
            border-radius: 4px;
            margin: 10px 0;
        }
        pre {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
            font-size: 12px;
        }
        
        /* HTML Form Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }
        
        .modal-content {
            background-color: #fefefe;
            margin: 2% auto;
            padding: 20px;
            border: none;
            border-radius: 8px;
            width: 90%;
            max-width: 900px;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
        
        .close:hover {
            color: black;
        }
        
        .html-form {
            max-width: 800px;
            margin: 0 auto;
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        .form-group input, .form-group textarea, .form-group select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        
        .form-group textarea {
            height: 80px;
            resize: vertical;
        }
        
        .checkbox-group, .radio-group {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 10px;
        }
        
        .checkbox-item, .radio-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .form-actions {
            text-align: center;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #eee;
        }
        
        .numberline {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
        }
        
        .numberline input[type="range"] {
            flex: 1;
        }
        
                 .range-labels {
             display: flex;
             justify-content: space-between;
             font-size: 12px;
             color: #666;
             margin-top: 5px;
         }
         
         .range-labels span:nth-child(2) {
             background: #007bff;
             color: white;
             padding: 2px 8px;
             border-radius: 4px;
             font-weight: bold;
         }
         
         /* Print styles for HTML form */
         @media print {
             .modal {
                 position: static !important;
                 background: none !important;
                 width: 100% !important;
                 height: auto !important;
             }
             
             .modal-content {
                 box-shadow: none !important;
                 border: none !important;
                 margin: 0 !important;
                 padding: 0 !important;
                 max-height: none !important;
                 overflow: visible !important;
             }
             
             .close {
                 display: none !important;
             }
             
             button {
                 display: none !important;
             }
             
             .form-actions {
                 display: none !important;
             }
         }
    </style>
</head>
<body>
    <h1>üîß Parent Survey PDF Generator Test</h1>
    
    <div class="container">
        <h2>Test the Survey PDF Generator</h2>
        <p>This will fetch the <code>parent_survey_family.json</code> from the Levante bucket and generate PDFs.</p>
        
        <button onclick="analyzeSurvey()">üìä Analyze Survey</button>
        
        <div class="button-group">
            <h3>üìÑ Printable PDFs (for printing and handwriting)</h3>
            <button onclick="generatePDF()" id="generateBtn">üìÑ Generate Printable PDF</button>
            <button onclick="generatePDFWithOptions()" id="generateOptionsBtn">‚öôÔ∏è Generate Detailed Printable PDF</button>
        </div>
        
        <div class="button-group">
            <h3>üìù Form-Style PDFs (enhanced visual forms)</h3>
            <button onclick="generateFillablePDF()" id="generateFillableBtn">üìù Generate Form-Style PDF</button>
            <button onclick="generateFillablePDFWithOptions()" id="generateFillableOptionsBtn">‚öôÔ∏è Generate Detailed Form-Style PDF</button>
        </div>
        
        <div class="button-group">
            <h3>üíª Digital Form Alternatives</h3>
            <button onclick="openHtmlForm()" id="htmlFormBtn">üíª Open Digital HTML Form (All Pages)</button>
            <button onclick="generateTrueFillablePDF()" id="trueFillableBtn">üìã Generate Interactive Fillable PDF (Click fields to fill)</button>
        </div>
    </div>

    <div id="status"></div>
    <div id="surveyInfo"></div>
    
    <!-- HTML Form Modal -->
    <div id="htmlFormModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeHtmlForm()">&times;</span>
            <h2>Digital Caregiver Survey</h2>
            <div id="htmlFormContent"></div>
        </div>
    </div>

    <script>
        const SURVEY_URL = 'https://storage.googleapis.com/levante-dashboard-dev/parent_survey_family.json';
        let surveyData = null;

        // Helper function to add logo to PDF
        async function addLogoToPdf(pdf, x, y, width = 25, height = 15) {
            try {
                const logoUrl = '/public/LEVANTE/Levante_Logo.png';
                const response = await fetch(logoUrl);
                const blob = await response.blob();
                
                return new Promise((resolve) => {
                    const reader = new FileReader();
                    reader.onload = function() {
                        const base64 = reader.result;
                        pdf.addImage(base64, 'PNG', x, y, width, height);
                        resolve();
                    };
                    reader.readAsDataURL(blob);
                });
            } catch (error) {
                console.warn('Could not load logo:', error);
                // If logo fails to load, continue without it
            }
        }

        // Simple PDF generator (simplified version of your utility)
        async function generatePdfFromSurvey(surveyJson, options = {}) {
            const { jsPDF } = window.jspdf;
            const pdf = new jsPDF('p', 'mm', 'a4');
            
            const defaultOptions = {
                title: surveyJson.title || 'Survey',
                includeQuestionNumbers: true,
                includePages: true,
                fontSize: 10,
                margin: 20,
                showChoices: true,
                showDescriptions: true,
                headerText: '',
                footerText: '',
                fillable: false  // New option for fillable forms
            };
            
            const mergedOptions = { ...defaultOptions, ...options };
            let currentY = mergedOptions.margin;
            let questionCounter = 1;

            // Add logo to first page
            await addLogoToPdf(pdf, mergedOptions.margin, 5);
            
            // Add title (moved down to accommodate logo)
            currentY = mergedOptions.margin + 5; // Extra space for logo
            if (mergedOptions.title) {
                pdf.setFontSize(16);
                pdf.setFont('helvetica', 'bold');
                pdf.text(mergedOptions.title, 105, currentY, { align: 'center' });
                currentY += 15;
            }

            // Add fill-in-the-blank fields for caregiver information
            pdf.setFontSize(10);
            pdf.setFont('helvetica', 'normal');
            
            if (mergedOptions.fillable) {
                // Create visual form fields that look fillable
                
                // Child's Name
                pdf.text("Child's Name:", mergedOptions.margin, currentY);
                pdf.setDrawColor(0);
                pdf.setFillColor(245, 245, 245); // Light gray background
                pdf.rect(mergedOptions.margin + 30, currentY - 4, 100, 6, 'FD'); // Filled rectangle with border
                currentY += 8;
                
                // Caregiver's Name
                pdf.text("Caregiver's Name:", mergedOptions.margin, currentY);
                pdf.rect(mergedOptions.margin + 40, currentY - 4, 100, 6, 'FD');
                currentY += 8;
                
                // Site and/or School
                pdf.text("Site and/or School:", mergedOptions.margin, currentY);
                pdf.rect(mergedOptions.margin + 42, currentY - 4, 100, 6, 'FD');
                currentY += 8;
                
                // Date Completed
                pdf.text("Date Completed:", mergedOptions.margin, currentY);
                pdf.rect(mergedOptions.margin + 38, currentY - 4, 60, 6, 'FD');
                currentY += 12;
                
            } else {
                // Static form with lines to fill in
                pdf.text("Child's Name: ________________________________", mergedOptions.margin, currentY);
                currentY += 8;
                
                pdf.text("Caregiver's Name: ________________________________", mergedOptions.margin, currentY);
                currentY += 8;
                
                pdf.text("Site and/or School: ________________________________", mergedOptions.margin, currentY);
                currentY += 8;
                
                pdf.text("Date Completed: ________________________________", mergedOptions.margin, currentY);
                currentY += 12;
            }

            // Process survey structure
            const pages = surveyJson.pages || [{ elements: surveyJson.elements || [] }];
            
            for (let pageIndex = 0; pageIndex < pages.length; pageIndex++) {
                const page = pages[pageIndex];
                // Add page title
                if (mergedOptions.includePages && pages.length > 1 && page.title) {
                    if (pageIndex > 0) {
                        pdf.addPage();
                        await addLogoToPdf(pdf, mergedOptions.margin, 5);
                        currentY = mergedOptions.margin + 5; // Extra space for logo
                    }
                    pdf.setFontSize(14);
                    pdf.setFont('helvetica', 'bold');
                    const pageTitle = extractText(page.title) || page.title;
                    pdf.text(pageTitle, mergedOptions.margin, currentY);
                    currentY += 10;
                }

                // Process elements with improved expansion
                const expandElements = (elements) => {
                    const expandedQuestions = [];
                    
                    elements.forEach(element => {
                        if (element.type === 'html') {
                            // HTML elements often contain instructions - keep them for instruction extraction
                            expandedQuestions.push(element);
                        } else if (element.type === 'panel' && element.elements) {
                            // Add panel as section header if it has a title or description
                            if (element.title || element.description) {
                                expandedQuestions.push({
                                    type: 'panel-header',
                                    title: element.title,
                                    description: element.description,
                                    name: element.name || 'panel'
                                });
                            }
                            // Expand panel elements
                            expandedQuestions.push(...expandElements(element.elements));
                        } else if (element.type === 'matrix') {
                            // Expand matrix questions - each row becomes a separate question
                            if (element.rows && element.rows.length > 0) {
                                element.rows.forEach(row => {
                                    const rowQuestion = {
                                        ...element,
                                        name: row.value,
                                        title: extractText(row.text) || row.value,
                                        type: 'matrix-row',
                                        choices: element.columns ? element.columns.map(col => ({
                                            value: col.value,
                                            text: extractText(col.text) || col.value
                                        })) : []
                                    };
                                    expandedQuestions.push(rowQuestion);
                                });
                            } else {
                                // Fallback if no rows
                                expandedQuestions.push(element);
                            }
                        } else {
                            // Regular question
                            expandedQuestions.push(element);
                        }
                    });
                    
                    return expandedQuestions;
                };

                const expandedElements = expandElements(page.elements || []);
                for (const element of expandedElements) {
                    // Check if we need a new page
                    if (currentY > 250) {
                        pdf.addPage();
                        await addLogoToPdf(pdf, mergedOptions.margin, 5);
                        currentY = mergedOptions.margin + 5; // Extra space for logo
                    }

                    currentY = addQuestionToPdf(pdf, element, questionCounter, currentY, mergedOptions);
                    questionCounter++;
                }
            }

            // Add footer with page numbers
            const pageCount = pdf.getNumberOfPages();
            for (let i = 1; i <= pageCount; i++) {
                pdf.setPage(i);
                pdf.setFontSize(8);
                pdf.setFont('helvetica', 'normal');
                const footerText = `Page ${i} out of ${pageCount}`;
                const pageWidth = pdf.internal.pageSize.getWidth();
                const textWidth = pdf.getTextWidth(footerText);
                const x = (pageWidth - textWidth) / 2; // Center the text
                pdf.text(footerText, x, 285);
            }

            return pdf;
        }

        // Helper function to draw a checkbox
        function drawCheckbox(pdf, x, y, size = 3) {
            pdf.setDrawColor(0); // Black border
            pdf.setFillColor(255, 255, 255); // White fill
            pdf.rect(x, y - size, size, size, 'FD'); // Draw filled rectangle with border
        }

        // Helper function to draw a radio button (circle)
        function drawRadioButton(pdf, x, y, radius = 1.5) {
            pdf.setDrawColor(0); // Black border
            pdf.setFillColor(255, 255, 255); // White fill
            pdf.circle(x + radius, y - radius/2, radius, 'FD'); // Draw filled circle with border
        }

        function addQuestionToPdf(pdf, element, questionNumber, startY, options) {
            let currentY = startY;
            
            // Handle HTML instruction elements
            if (element.type === 'html') {
                if (element.html) {
                    const instructionText = parseHtmlToText(element.html);
                    if (instructionText) {
                        pdf.setFontSize(options.fontSize);
                        pdf.setFont('helvetica', 'italic');
                        const lines = pdf.splitTextToSize(instructionText, 170);
                        lines.forEach((line, index) => {
                            pdf.text(line, options.margin, currentY);
                            currentY += 5;
                        });
                        currentY += 3; // Extra spacing after instructions
                    }
                }
                return currentY;
            }
            
            // Handle panel headers (section dividers)
            if (element.type === 'panel-header') {
                currentY += 5; // Extra space before section
                
                if (element.title) {
                    const sectionTitle = extractText(element.title);
                    pdf.setFontSize(options.fontSize + 3);
                    pdf.setFont('helvetica', 'bold');
                    const lines = pdf.splitTextToSize(sectionTitle, 170);
                    lines.forEach((line, index) => {
                        pdf.text(line, options.margin, currentY);
                        currentY += 6;
                    });
                    currentY += 2;
                }
                
                if (element.description) {
                    const sectionDescription = parseHtmlToText(element.description);
                    if (sectionDescription) {
                        pdf.setFontSize(options.fontSize);
                        pdf.setFont('helvetica', 'italic');
                        const lines = pdf.splitTextToSize(sectionDescription, 170);
                        lines.forEach((line, index) => {
                            pdf.text(line, options.margin + 5, currentY);
                            currentY += 5;
                        });
                        currentY += 3;
                    }
                }
                
                currentY += 5; // Extra space after section
                return currentY;
            }
            
            // Question title
            const questionTitle = options.includeQuestionNumbers 
                ? `${questionNumber}. ${getElementTitle(element)}`
                : getElementTitle(element);
            
            pdf.setFontSize(options.fontSize + 1);
            pdf.setFont('helvetica', 'bold');
            const lines = pdf.splitTextToSize(questionTitle, 170);
            lines.forEach((line, index) => {
                pdf.text(line, options.margin, currentY);
                currentY += 5;
            });

            // Extract and display instructions/descriptions
            let instructions = '';
            if (element.description) {
                instructions = parseHtmlToText(element.description);
            } else if (element.descriptionHtml) {
                instructions = parseHtmlToText(element.descriptionHtml);
            } else if (element.html) {
                instructions = parseHtmlToText(element.html);
            }
            
            if (instructions) {
                pdf.setFontSize(options.fontSize - 1);
                pdf.setFont('helvetica', 'italic');
                const instructionLines = pdf.splitTextToSize(instructions, 170);
                instructionLines.forEach((line, index) => {
                    pdf.text(line, options.margin + 5, currentY);
                    currentY += 4;
                });
                currentY += 3; // Extra spacing after instructions
            }

            // Question content based on type
            pdf.setFontSize(options.fontSize);
            pdf.setFont('helvetica', 'normal');
            
            switch (element.type) {
                case 'boolean':
                    const trueLabel = extractText(element.labelTrue) || 'Yes';
                    const falseLabel = extractText(element.labelFalse) || 'No';
                    
                    if (options.fillable) {
                        // Create visual radio buttons that look fillable
                        pdf.setDrawColor(0);
                        pdf.setFillColor(255, 255, 255); // White background
                        
                        // Draw Yes radio button
                        pdf.circle(options.margin + 10, currentY - 1, 2, 'FD');
                        pdf.text(`${trueLabel}`, options.margin + 15, currentY);
                        
                        // Draw No radio button
                        pdf.circle(options.margin + 60, currentY - 1, 2, 'FD');
                        pdf.text(`${falseLabel}`, options.margin + 65, currentY);
                        
                    } else {
                        // Draw static checkboxes
                        drawCheckbox(pdf, options.margin + 5, currentY);
                        pdf.text(`${trueLabel}`, options.margin + 12, currentY);
                        
                        const trueLabelWidth = pdf.getTextWidth(trueLabel);
                        const checkboxSpacing = Math.max(30, trueLabelWidth + 20);
                        drawCheckbox(pdf, options.margin + 5 + checkboxSpacing, currentY);
                        pdf.text(`${falseLabel}`, options.margin + 12 + checkboxSpacing, currentY);
                    }
                    
                    currentY += 8;
                    break;
                    
                case 'radiogroup':
                case 'dropdown':
                    if (options.showChoices && element.choices) {
                        if (options.fillable) {
                            if (element.type === 'radiogroup') {
                                // Create visual radio buttons
                                pdf.setDrawColor(0);
                                pdf.setFillColor(255, 255, 255);
                                
                                element.choices.forEach((choice, index) => {
                                    const choiceText = typeof choice === 'string' ? choice : extractText(choice.text) || extractText(choice) || choice.value || choice;
                                    
                                    // Draw radio button circle
                                    pdf.circle(options.margin + 10, currentY - 1, 2, 'FD');
                                    pdf.text(`${choiceText}`, options.margin + 15, currentY);
                                    currentY += 6;
                                });
                                
                            } else {
                                // Create visual dropdown box
                                pdf.setDrawColor(0);
                                pdf.setFillColor(245, 245, 245);
                                pdf.rect(options.margin + 5, currentY - 4, 120, 6, 'FD');
                                
                                // Add dropdown arrow indicator
                                pdf.text('‚ñº', options.margin + 115, currentY - 1);
                                pdf.text('Select option...', options.margin + 8, currentY - 1);
                                currentY += 8;
                            }
                        } else {
                            // Static form with visual elements
                            element.choices.forEach(choice => {
                                const choiceText = typeof choice === 'string' ? choice : extractText(choice.text) || extractText(choice) || choice.value || choice;
                                
                                if (element.type === 'radiogroup') {
                                    drawRadioButton(pdf, options.margin + 5, currentY);
                                    pdf.text(`${choiceText}`, options.margin + 12, currentY);
                                } else {
                                    // For dropdown, just show numbered list
                                    pdf.text(`  ${element.choices.indexOf(choice) + 1}. ${choiceText}`, options.margin + 5, currentY);
                                }
                                currentY += 6;
                            });
                        }
                    }
                    break;
                    
                case 'checkbox':
                    if (options.showChoices && element.choices) {
                        if (options.fillable) {
                            // Create visual checkboxes for multiple selection
                            pdf.setDrawColor(0);
                            pdf.setFillColor(255, 255, 255);
                            
                            element.choices.forEach((choice, index) => {
                                const choiceText = typeof choice === 'string' ? choice : extractText(choice.text) || extractText(choice) || choice.value || choice;
                                
                                // Draw checkbox rectangle
                                pdf.rect(options.margin + 5, currentY - 3, 3, 3, 'FD');
                                pdf.text(`${choiceText}`, options.margin + 12, currentY);
                                currentY += 6;
                            });
                        } else {
                            // Static checkboxes
                            element.choices.forEach(choice => {
                                const choiceText = typeof choice === 'string' ? choice : extractText(choice.text) || extractText(choice) || choice.value || choice;
                                
                                drawCheckbox(pdf, options.margin + 5, currentY);
                                pdf.text(`${choiceText}`, options.margin + 12, currentY);
                                currentY += 6;
                            });
                        }
                    }
                    break;
                    
                case 'matrix-row':
                    // Individual matrix row question
                    if (options.showChoices && element.choices) {
                        // Show as radio buttons with the matrix column choices
                        element.choices.forEach(choice => {
                            const choiceText = typeof choice === 'string' ? choice : extractText(choice.text) || extractText(choice) || choice.value || choice;
                            
                            drawRadioButton(pdf, options.margin + 5, currentY);
                            pdf.text(`${choiceText}`, options.margin + 12, currentY);
                            currentY += 6;
                        });
                    } else {
                        pdf.text('  ________________', options.margin + 5, currentY);
                        currentY += 6;
                    }
                    break;
                    
                case 'matrix':
                    // Full matrix question (if not expanded into rows)
                    pdf.text('  Matrix Question - Please refer to original survey for full layout', options.margin + 5, currentY);
                    currentY += 6;
                    break;
                    
                case 'text':
                    if (element.inputType === 'range') {
                        // This is a numberline/slider question
                        const min = element.min || 0;
                        const max = element.max || 10;
                        
                        // Add instruction text
                        pdf.setFontSize(options.fontSize - 1);
                        pdf.setFont('helvetica', 'italic');
                        pdf.text('Please mark your position on the line below:', options.margin + 5, currentY);
                        currentY += 8;
                        
                        if (options.fillable) {
                            // Create visual text field for range input
                            pdf.setDrawColor(0);
                            pdf.setFillColor(245, 245, 245);
                            pdf.rect(options.margin + 5, currentY - 4, 60, 6, 'FD');
                            pdf.text(`(Enter value ${min}-${max})`, options.margin + 70, currentY);
                            currentY += 8;
                        } else {
                            // Draw the static numberline
                            pdf.setFont('helvetica', 'normal');
                            currentY = drawNumberline(pdf, options.margin + 5, currentY, 120, min, max);
                            currentY += 5;
                        }
                        
                    } else {
                        if (options.fillable) {
                            // Create visual text field
                            pdf.setDrawColor(0);
                            pdf.setFillColor(245, 245, 245);
                            pdf.rect(options.margin + 5, currentY - 4, 120, 6, 'FD');
                            
                            if (element.inputType === 'email') {
                                pdf.text('(Email)', options.margin + 130, currentY - 1);
                            }
                            
                            currentY += 8;
                        } else {
                            const inputTypeText = element.inputType ? ` (${element.inputType})` : '';
                            pdf.text(`  ________________${inputTypeText}`, options.margin + 5, currentY);
                            currentY += 6;
                        }
                    }
                    break;
                    
                case 'comment':
                    if (options.fillable) {
                        // Create visual multiline text field
                        const rows = element.rows || 3;
                        const fieldHeight = rows * 6;
                        
                        pdf.setDrawColor(0);
                        pdf.setFillColor(245, 245, 245);
                        pdf.rect(options.margin + 5, currentY - 4, 150, fieldHeight, 'FD');
                        
                        // Add lines for writing
                        pdf.setDrawColor(200, 200, 200); // Light gray lines
                        for (let i = 1; i < rows; i++) {
                            const lineY = currentY - 4 + (i * 6);
                            pdf.line(options.margin + 8, lineY, options.margin + 152, lineY);
                        }
                        pdf.setDrawColor(0); // Reset to black
                        
                        currentY += fieldHeight + 5;
                    } else {
                        const rows = element.rows || 3;
                        for (let i = 0; i < rows; i++) {
                            pdf.text('  ________________________________________________', options.margin + 5, currentY);
                            currentY += 5;
                        }
                    }
                    break;
                    
                default:
                    pdf.text('  ________________', options.margin + 5, currentY);
                    currentY += 6;
                    break;
            }
            
            return currentY + 3; // Add spacing
        }

        // Helper function to extract text from multilingual objects
        function extractText(textObj) {
            if (!textObj) return '';
            if (typeof textObj === 'string') return textObj;
            if (typeof textObj === 'number') return String(textObj);
            if (typeof textObj === 'object' && textObj) {
                // Handle different object structures for text
                if (textObj.default) return extractText(textObj.default);
                if (textObj.en) return extractText(textObj.en);
                if (textObj.es) return extractText(textObj.es);
                if (textObj.de) return extractText(textObj.de);
                if (textObj.text) return extractText(textObj.text);
                if (textObj.value) return extractText(textObj.value);
                if (textObj.title) return extractText(textObj.title);
                
                // If it's an array, join the elements
                if (Array.isArray(textObj)) {
                    return textObj.map(item => extractText(item)).filter(text => text).join(', ');
                }
                
                // For other objects, try to get the first meaningful value
                const values = Object.values(textObj).filter(val => val && val !== textObj);
                if (values.length > 0) {
                    const firstValue = values[0];
                    if (typeof firstValue === 'string') return firstValue;
                    if (typeof firstValue === 'object') return extractText(firstValue);
                }
                
                // Last resort: avoid [object Object]
                return '';
            }
            return String(textObj);
        }

        // Helper function to parse HTML and convert to plain text
        function parseHtmlToText(html) {
            if (!html) return '';
            
            // If it's already plain text, return it
            if (typeof html === 'string' && !html.includes('<')) {
                return html.trim();
            }
            
            // Create a temporary div to parse HTML
            const div = document.createElement('div');
            div.innerHTML = html;
            
            // Extract text content and clean it up
            let text = div.textContent || div.innerText || '';
            
            // Clean up common HTML artifacts
            text = text.replace(/\s+/g, ' ').trim();
            text = text.replace(/&nbsp;/g, ' ');
            text = text.replace(/&amp;/g, '&');
            text = text.replace(/&lt;/g, '<');
            text = text.replace(/&gt;/g, '>');
            text = text.replace(/&quot;/g, '"');
            
            return text;
        }

        // Helper function to draw a numberline/slider
        function drawNumberline(pdf, x, y, width = 120, min = 0, max = 10) {
            const lineY = y;
            const lineStartX = x;
            const lineEndX = x + width;
            
            // Draw the main line
            pdf.setDrawColor(0);
            pdf.setLineWidth(0.5);
            pdf.line(lineStartX, lineY, lineEndX, lineY);
            
            // Draw start and end markers
            pdf.line(lineStartX, lineY - 2, lineStartX, lineY + 2);
            pdf.line(lineEndX, lineY - 2, lineEndX, lineY + 2);
            
            // Add labels
            pdf.setFontSize(8);
            pdf.text(min.toString(), lineStartX - 2, lineY + 6);
            pdf.text(max.toString(), lineEndX - 2, lineY + 6);
            
            // Draw tick marks for intermediate values
            if (max - min <= 10) {
                for (let i = min + 1; i < max; i++) {
                    const tickX = lineStartX + ((i - min) / (max - min)) * width;
                    pdf.line(tickX, lineY - 1, tickX, lineY + 1);
                    if (i % 2 === 0) { // Label every other tick
                        pdf.text(i.toString(), tickX - 1, lineY + 6);
                    }
                }
            }
            
            return lineY + 12; // Return next Y position
        }

        function getElementTitle(element) {
            if (!element.title) return element.name || 'Untitled Question';
            
            const titleText = extractText(element.title) || element.name || 'Untitled Question';
            
            // If the title contains HTML, parse it to clean text
            if (titleText.includes('<') && titleText.includes('>')) {
                return parseHtmlToText(titleText);
            }
            
            return titleText;
        }

        function showStatus(message, type = 'info') {
            const statusDiv = document.getElementById('status');
            statusDiv.innerHTML = `<div class="status ${type}">${message}</div>`;
        }

        function showSurveyInfo(survey) {
            const infoDiv = document.getElementById('surveyInfo');
            
            let totalQuestions = 0;
            const questionTypes = new Set();
            
            const countElements = (elements) => {
                elements.forEach(element => {
                    if (element.type === 'html') {
                        // Skip HTML elements
                        return;
                    } else if (element.type === 'panel' && element.elements) {
                        // Expand panel elements
                        countElements(element.elements);
                    } else if (element.type === 'matrix' && element.rows) {
                        // Matrix questions - each row is a separate question
                        totalQuestions += element.rows.length;
                        questionTypes.add('matrix-row');
                    } else {
                        // Regular question
                        totalQuestions++;
                        questionTypes.add(element.type);
                    }
                });
            };

            if (survey.pages) {
                survey.pages.forEach(page => {
                    if (page.elements) countElements(page.elements);
                });
            } else if (survey.elements) {
                countElements(survey.elements);
            }

            infoDiv.innerHTML = `
                <div class="survey-info">
                    <h3>üìã Survey Analysis</h3>
                    <p><strong>Title:</strong> ${survey.title || 'No title'}</p>
                    <p><strong>Pages:</strong> ${survey.pages?.length || 1}</p>
                    <p><strong>Total Questions:</strong> ${totalQuestions}</p>
                    <p><strong>Question Types:</strong> ${Array.from(questionTypes).join(', ')}</p>
                    <details>
                        <summary>Raw Survey JSON (first 1000 chars)</summary>
                        <pre>${JSON.stringify(survey, null, 2).substring(0, 1000)}...</pre>
                    </details>
                </div>
            `;
        }

        async function analyzeSurvey() {
            showStatus('üîÑ Fetching survey data...', 'info');
            
            try {
                const response = await fetch(SURVEY_URL);
                if (!response.ok) {
                    throw new Error(`Failed to fetch: ${response.statusText}`);
                }
                
                surveyData = await response.json();
                showStatus('‚úÖ Survey data loaded successfully!', 'success');
                showSurveyInfo(surveyData);
                
                // Enable buttons
                            document.getElementById('generateBtn').disabled = false;
            document.getElementById('generateOptionsBtn').disabled = false;
            document.getElementById('generateFillableBtn').disabled = false;
            document.getElementById('generateFillableOptionsBtn').disabled = false;
            document.getElementById('htmlFormBtn').disabled = false;
            document.getElementById('trueFillableBtn').disabled = false;
                
            } catch (error) {
                showStatus(`‚ùå Error loading survey: ${error.message}`, 'error');
            }
        }

        async function generatePDF() {
            if (!surveyData) {
                await analyzeSurvey();
                if (!surveyData) return;
            }

            showStatus('üîÑ Generating PDF...', 'info');

            try {
                const pdf = await generatePdfFromSurvey(surveyData, {
                    title: 'Caregiver Survey'
                });

                // Download the PDF
                pdf.save('caregiver_survey.pdf');
                showStatus('‚úÖ PDF generated and downloaded successfully!', 'success');

            } catch (error) {
                showStatus(`‚ùå Error generating PDF: ${error.message}`, 'error');
            }
        }

        async function generatePDFWithOptions() {
            if (!surveyData) {
                await analyzeSurvey();
                if (!surveyData) return;
            }

            showStatus('üîÑ Generating PDF with custom options...', 'info');

            try {
                const pdf = await generatePdfFromSurvey(surveyData, {
                    title: 'Caregiver Survey',
                    includeQuestionNumbers: true,
                    includePages: true,
                    fontSize: 11,
                    margin: 25,
                    showChoices: true,
                    showDescriptions: true
                });

                // Download the PDF
                pdf.save('caregiver_survey_detailed.pdf');
                showStatus('‚úÖ Detailed PDF generated and downloaded successfully!', 'success');

            } catch (error) {
                showStatus(`‚ùå Error generating PDF: ${error.message}`, 'error');
            }
        }

        async function generateFillablePDF() {
            if (!surveyData) {
                await analyzeSurvey();
                if (!surveyData) return;
            }

            showStatus('üîÑ Generating form-style PDF...', 'info');

            try {
                const pdf = await generatePdfFromSurvey(surveyData, {
                    title: 'Caregiver Survey',
                    fillable: true
                });

                // Download the PDF
                pdf.save('caregiver_survey_form_style.pdf');
                showStatus('‚úÖ Form-style PDF generated and downloaded successfully!', 'success');

            } catch (error) {
                showStatus(`‚ùå Error generating form-style PDF: ${error.message}`, 'error');
            }
        }

        async function generateFillablePDFWithOptions() {
            if (!surveyData) {
                await analyzeSurvey();
                if (!surveyData) return;
            }

            showStatus('üîÑ Generating detailed form-style PDF...', 'info');

            try {
                const pdf = await generatePdfFromSurvey(surveyData, {
                    title: 'Caregiver Survey',
                    includeQuestionNumbers: true,
                    includePages: true,
                    fontSize: 11,
                    margin: 25,
                    showChoices: true,
                    showDescriptions: true,
                    fillable: true
                });

                // Download the PDF
                pdf.save('caregiver_survey_form_style_detailed.pdf');
                showStatus('‚úÖ Detailed form-style PDF generated and downloaded successfully!', 'success');

            } catch (error) {
                showStatus(`‚ùå Error generating form-style PDF: ${error.message}`, 'error');
            }
        }

        // HTML Form Modal Functions
                 function openHtmlForm() {
             const modal = document.getElementById('htmlFormModal');
             modal.style.display = 'block';
             document.getElementById('htmlFormContent').innerHTML = ''; // Clear previous content
             
             // Process ALL pages, not just the first one
             let allElements = [];
             if (surveyData.pages && surveyData.pages.length > 0) {
                 // Multi-page survey - collect elements from all pages
                 surveyData.pages.forEach(page => {
                     if (page.elements && page.elements.length > 0) {
                         allElements = allElements.concat(page.elements);
                     }
                 });
             } else if (surveyData.elements) {
                 // Single page survey
                 allElements = surveyData.elements;
             }
             
             if (allElements.length > 0) {
                 createHtmlForm(allElements);
             } else {
                 document.getElementById('htmlFormContent').innerHTML = '<p>No survey elements found.</p>';
             }
         }

        function closeHtmlForm() {
            document.getElementById('htmlFormModal').style.display = 'none';
        }

                 function createHtmlForm(elements) {
             const formContent = document.getElementById('htmlFormContent');
             
             // Add header information
             formContent.innerHTML = `
                 <div class="html-form">
                     <div class="form-group">
                         <h3>Caregiver Information</h3>
                         <label for="childName">Child's Name:</label>
                         <input type="text" id="childName" name="childName" placeholder="Enter child's full name">
                     </div>
                     
                     <div class="form-group">
                         <label for="caregiverName">Caregiver's Name:</label>
                         <input type="text" id="caregiverName" name="caregiverName" placeholder="Enter caregiver's full name">
                     </div>
                     
                     <div class="form-group">
                         <label for="siteSchool">Site and/or School:</label>
                         <input type="text" id="siteSchool" name="siteSchool" placeholder="Enter site or school name">
                     </div>
                     
                     <div class="form-group">
                         <label for="dateCompleted">Date Completed:</label>
                         <input type="date" id="dateCompleted" name="dateCompleted">
                     </div>
                     
                     <hr style="margin: 30px 0;">
                     <h3>Survey Questions</h3>
             `;

             renderFormElements(elements, formContent);
             
             // Add form actions
             formContent.innerHTML += `
                 <div class="form-actions">
                     <button type="button" onclick="printForm()" style="background: #28a745;">üñ®Ô∏è Print Form</button>
                     <button type="button" onclick="saveFormData()" style="background: #17a2b8;">üíæ Save Data</button>
                     <button type="button" onclick="closeHtmlForm()" style="background: #6c757d;">‚ùå Close</button>
                 </div>
                 </div>
             `;
         }
         
         function renderFormElements(elements, container) {
             elements.forEach(element => {
                 if (element.type === 'html') {
                     // For HTML elements, just display the HTML
                     container.innerHTML += `<div class="form-group">${element.html}</div>`;
                 } else if (element.type === 'panel-header') {
                     // For panel headers, create section dividers
                     let sectionHtml = '<div class="form-section" style="margin: 30px 0 20px 0; padding: 15px; background: #f8f9fa; border-left: 4px solid #007bff; border-radius: 4px;">';
                     if (element.title) {
                         const sectionTitle = extractText(element.title);
                         sectionHtml += `<h3 style="margin: 0 0 10px 0; color: #333; font-size: 18px;">${sectionTitle}</h3>`;
                     }
                     if (element.description) {
                         const sectionDescription = parseHtmlToText(element.description);
                         sectionHtml += `<p style="margin: 0; color: #666; font-style: italic;">${sectionDescription}</p>`;
                     }
                     sectionHtml += '</div>';
                     container.innerHTML += sectionHtml;
                 } else if (element.type === 'panel' && element.elements) {
                     // For panels, recursively create form groups
                     container.innerHTML += `<div class="form-group"><h4>${element.title || 'Panel'}</h4></div>`;
                     renderFormElements(element.elements, container);
                 } else if (element.type === 'matrix' && element.rows) {
                     // For matrix questions, create a group for each row
                     const matrixTitle = getElementTitle(element);
                     container.innerHTML += `<div class="form-group"><h4>${matrixTitle}</h4></div>`;
                     
                     element.rows.forEach(row => {
                         const rowTitle = extractText(row.text) || row.value;
                         container.innerHTML += `<div class="form-group">
                             <label>${rowTitle}:</label>
                             <div class="radio-group">`;
                         
                         // Add radio buttons for matrix row choices if they exist
                         if (element.columns && element.columns.length > 0) {
                             element.columns.forEach(col => {
                                 let choiceText = '';
                                 let colValue = '';
                                 
                                 if (typeof col === 'string') {
                                     choiceText = col;
                                     colValue = col;
                                 } else if (typeof col === 'object' && col) {
                                     choiceText = extractText(col.text) || extractText(col.title) || extractText(col) || col.value || '';
                                     colValue = col.value || choiceText || '';
                                 } else {
                                     choiceText = String(col);
                                     colValue = String(col);
                                 }
                                 
                                 container.innerHTML += `
                                     <div class="radio-item">
                                         <input type="radio" id="matrix_${element.name}_${row.value}_${colValue}" name="matrix_${element.name}_${row.value}" value="${colValue}">
                                         <label for="matrix_${element.name}_${row.value}_${colValue}">${choiceText}</label>
                                     </div>`;
                             });
                         }
                         container.innerHTML += `</div></div>`;
                     });
                 } else {
                     // For other question types, create a standard form group
                     const questionHtml = createQuestionHtml(element);
                     if (questionHtml.trim()) {
                         container.innerHTML += questionHtml;
                     }
                 }
             });
         }

        function createQuestionHtml(element) {
            let html = '';
            const questionTitle = getElementTitle(element);
            const questionNumber = element.name ? element.name.replace(/[^a-zA-Z0-9]/g, '_') : 'question';

            // Extract instructions for all question types
            let instructions = '';
            if (element.description) {
                instructions = parseHtmlToText(element.description);
            } else if (element.descriptionHtml) {
                instructions = parseHtmlToText(element.descriptionHtml);
            } else if (element.html) {
                instructions = parseHtmlToText(element.html);
            }

            if (element.type === 'boolean') {
                html += `<div class="form-group">
                    <label for="${questionNumber}">${questionTitle}:</label>
                    ${instructions ? `<p style="font-size: 14px; color: #666; margin: 10px 0;">${instructions}</p>` : ''}
                    <div class="checkbox-group">
                        <input type="radio" id="${questionNumber}_true" name="${questionNumber}" value="true">
                        <label for="${questionNumber}_true">${extractText(element.labelTrue) || 'Yes'}</label>
                        <input type="radio" id="${questionNumber}_false" name="${questionNumber}" value="false">
                        <label for="${questionNumber}_false">${extractText(element.labelFalse) || 'No'}</label>
                    </div>
                </div>`;
            } else if (element.type === 'radiogroup' || element.type === 'dropdown') {
                html += `<div class="form-group">
                    <label for="${questionNumber}">${questionTitle}:</label>
                    ${instructions ? `<p style="font-size: 14px; color: #666; margin: 10px 0;">${instructions}</p>` : ''}
                                         <select id="${questionNumber}" name="${questionNumber}">
                         <option value="">${extractText(element.placeholder) || 'Select an option'}</option>
                         ${element.choices ? element.choices.map(choice => {
                             let choiceText = '';
                             let choiceValue = '';
                             
                             if (typeof choice === 'string') {
                                 choiceText = choice;
                                 choiceValue = choice;
                             } else if (typeof choice === 'object' && choice) {
                                 choiceText = extractText(choice.text) || extractText(choice.title) || extractText(choice) || choice.value || '';
                                 choiceValue = choice.value || choiceText || '';
                             } else {
                                 choiceText = String(choice);
                                 choiceValue = String(choice);
                             }
                             
                             return `<option value="${choiceValue}">${choiceText}</option>`;
                         }).join('') : ''}
                     </select>
                </div>`;
            } else if (element.type === 'checkbox') {
                html += `<div class="form-group">
                    <label for="${questionNumber}">${questionTitle}:</label>
                    ${instructions ? `<p style="font-size: 14px; color: #666; margin: 10px 0;">${instructions}</p>` : ''}
                    <div class="checkbox-group">
                                                 ${element.choices ? element.choices.map(choice => {
                             let choiceText = '';
                             let choiceValue = '';
                             
                             if (typeof choice === 'string') {
                                 choiceText = choice;
                                 choiceValue = choice;
                             } else if (typeof choice === 'object' && choice) {
                                 choiceText = extractText(choice.text) || extractText(choice.title) || extractText(choice) || choice.value || '';
                                 choiceValue = choice.value || choiceText || '';
                             } else {
                                 choiceText = String(choice);
                                 choiceValue = String(choice);
                             }
                             
                             return `<div class="checkbox-item">
                                 <input type="checkbox" id="${questionNumber}_${choiceValue}" name="${questionNumber}" value="${choiceValue}">
                                 <label for="${questionNumber}_${choiceValue}">${choiceText}</label>
                             </div>`;
                         }).join('') : ''}
                    </div>
                </div>`;
                         } else if (element.type === 'text' && element.inputType === 'range') {
                 // Parse HTML instructions for better display
                 let instructions = '';
                 if (element.html) {
                     instructions = parseHtmlToText(element.html);
                 } else if (element.description) {
                     instructions = parseHtmlToText(element.description);
                 } else if (element.descriptionHtml) {
                     instructions = parseHtmlToText(element.descriptionHtml);
                 }
                 
                 // If still no instructions, provide default for timeline questions
                 if (!instructions) {
                     instructions = 'Use the slider to indicate your response on the timeline.';
                 }
                 
                 html += `<div class="form-group">
                     <label for="${questionNumber}">${questionTitle}:</label>
                     ${instructions ? `<p style="font-size: 14px; color: #666; margin: 10px 0;">${instructions}</p>` : ''}
                     <div class="numberline">
                         <input type="range" id="${questionNumber}" name="${questionNumber}" min="${element.min || 0}" max="${element.max || 10}" value="${element.value || (element.min || 0)}" 
                                oninput="document.getElementById('${questionNumber}_value').textContent = this.value">
                         <div class="range-labels">
                             <span>${element.min || 0}</span>
                             <span id="${questionNumber}_value">${element.value || (element.min || 0)}</span>
                             <span>${element.max || 10}</span>
                         </div>
                     </div>
                     <input type="number" placeholder="Or enter exact value" min="${element.min || 0}" max="${element.max || 10}" 
                            style="margin-top: 10px; width: 100px;" 
                            oninput="document.getElementById('${questionNumber}').value = this.value; document.getElementById('${questionNumber}_value').textContent = this.value;">
                 </div>`;
            } else if (element.type === 'comment') {
                html += `<div class="form-group">
                    <label for="${questionNumber}">${questionTitle}:</label>
                    ${instructions ? `<p style="font-size: 14px; color: #666; margin: 10px 0;">${instructions}</p>` : ''}
                    <textarea id="${questionNumber}" name="${questionNumber}" rows="${element.rows || 3}" cols="50"></textarea>
                </div>`;
            } else {
                html += `<div class="form-group">
                    <label for="${questionNumber}">${questionTitle}:</label>
                    ${instructions ? `<p style="font-size: 14px; color: #666; margin: 10px 0;">${instructions}</p>` : ''}
                    <input type="text" id="${questionNumber}" name="${questionNumber}" value="${element.value || ''}">
                </div>`;
            }
                         return html;
         }
         
         // Helper functions for PDF generation
         function parseHtmlToText(html) {
             if (!html) return '';
             // Create a temporary div to parse HTML
             const tempDiv = document.createElement('div');
             tempDiv.innerHTML = html;
             return tempDiv.textContent || tempDiv.innerText || '';
         }
         
         function wrapText(text, maxLength) {
             if (!text) return [];
             const words = text.split(' ');
             const lines = [];
             let currentLine = '';
             
             words.forEach(word => {
                 if (currentLine.length + word.length + 1 <= maxLength) {
                     currentLine += (currentLine ? ' ' : '') + word;
                 } else {
                     if (currentLine) lines.push(currentLine);
                     currentLine = word;
                 }
             });
             
             if (currentLine) lines.push(currentLine);
             return lines;
         }

         // Helper function to draw wrapped text and return the new Y position
         function drawWrappedText(page, text, x, y, font, size, color = PDFLib.rgb(0, 0, 0), maxWidth = 500) {
             // More accurate character width calculation based on font size
             const avgCharWidth = size * 0.5; // Helvetica average character width
             const maxCharsPerLine = Math.floor(maxWidth / avgCharWidth);
             const lines = wrapText(text, maxCharsPerLine);
             let currentY = y;
             
             lines.forEach(line => {
                 page.drawText(line, { x, y: currentY, size, font, color });
                 currentY -= size + 3; // Line spacing (font size + 3px)
             });
             
             return currentY - 5; // Add extra spacing after the wrapped text
         }

         // Form action functions
         function printForm() {
             window.print();
         }
         
         function saveFormData() {
             const formData = new FormData();
             const inputs = document.querySelectorAll('#htmlFormContent input, #htmlFormContent textarea, #htmlFormContent select');
             const data = {};
             
             inputs.forEach(input => {
                 if (input.type === 'checkbox' || input.type === 'radio') {
                     if (input.checked) {
                         if (data[input.name]) {
                             if (Array.isArray(data[input.name])) {
                                 data[input.name].push(input.value);
                             } else {
                                 data[input.name] = [data[input.name], input.value];
                             }
                         } else {
                             data[input.name] = input.value;
                         }
                     }
                 } else {
                     data[input.name] = input.value;
                 }
             });
             
             // Save to local storage or display alert
             localStorage.setItem('caregiverSurveyData', JSON.stringify(data));
             alert('Form data saved to browser storage!');
             console.log('Saved form data:', data);
         }

                  // Function to add footers to all pages
         async function addFootersToAllPages(pdfDoc) {
             const pages = pdfDoc.getPages();
             const totalPages = pages.length;
             const footerFont = await pdfDoc.embedFont(PDFLib.StandardFonts.Helvetica);
             
             pages.forEach((page, index) => {
                 const pageNumber = index + 1;
                 const footerText = `Levante Caregiver Survey 2025 -- Page ${pageNumber} of ${totalPages}`;
                 
                 // Position footer at bottom center of page
                 const textWidth = footerFont.widthOfTextAtSize(footerText, 10);
                 const pageWidth = page.getSize().width;
                 const centerX = (pageWidth - textWidth) / 2;
                 
                 page.drawText(footerText, {
                     x: centerX,
                     y: 30, // 30 units from bottom
                     size: 10,
                     font: footerFont,
                     color: PDFLib.rgb(0.4, 0.4, 0.4) // Gray color
                 });
             });
         }

         // Function to calculate space needed for a question
         function calculateQuestionSpace(element) {
             let spaceNeeded = 35; // Base space for question title and margin
             
             // Add space for instructions if they exist
             let instructions = '';
             if (element.description) {
                 instructions = parseHtmlToText(element.description);
             } else if (element.descriptionHtml) {
                 instructions = parseHtmlToText(element.descriptionHtml);
             } else if (element.html) {
                 instructions = parseHtmlToText(element.html);
             }
             
             if (instructions) {
                 const instructionLines = Math.ceil(instructions.length / 70); // Rough estimate
                 spaceNeeded += instructionLines * 12 + 15; // 12px per line + padding
             }
             
             if (element.type === 'html') {
                 // HTML instruction elements only
                 return spaceNeeded;
             } else if (element.type === 'panel-header') {
                 // Panel headers need space for title and description
                 spaceNeeded += 30; // Base space for section header
                 if (element.title) {
                     const titleText = extractText(element.title);
                     const titleLines = Math.ceil(titleText.length / 60);
                     spaceNeeded += titleLines * 16; // 14px font + spacing
                 }
                 if (element.description) {
                     const descText = parseHtmlToText(element.description);
                     const descLines = Math.ceil(descText.length / 70);
                     spaceNeeded += descLines * 12; // 10px font + spacing
                 }
                 return spaceNeeded;
             } else if (element.type === 'boolean') {
                 // Title + yes/no options
                 spaceNeeded += 35; // 25 for options + 10 margin
             } else if (element.type === 'radiogroup') {
                 // Title + all radio options stacked vertically
                 const numChoices = element.choices ? element.choices.length : 0;
                 spaceNeeded += (numChoices * 25) + 10; // 25 per choice + margin
             } else if (element.type === 'checkbox') {
                 // Title + all checkbox options stacked vertically  
                 const numChoices = element.choices ? element.choices.length : 0;
                 spaceNeeded += (numChoices * 25) + 10; // 25 per choice + margin
             } else if (element.type === 'matrix-row') {
                 // Title + all matrix options stacked vertically
                 const numChoices = element.choices ? element.choices.length : 0;
                 spaceNeeded += (numChoices * 25) + 10; // 25 per choice + margin
             } else if (element.type === 'text' && element.inputType === 'range') {
                 // Timeline questions need lots of space for enhanced instructions, scale, and input
                 spaceNeeded += 180; // Enhanced instructions + visual scale + input field
             } else if (element.type === 'comment') {
                 // Multiline text area needs more space
                 spaceNeeded += 70; // Large text field
             } else if (element.type === 'text') {
                 // Regular text input
                 spaceNeeded += 35; // Text field
             }
             
             return spaceNeeded;
         }

         // True Fillable PDF (PDF-lib)
         async function generateTrueFillablePDF() {
             if (!surveyData) {
                 await analyzeSurvey();
                 if (!surveyData) return;
             }

             showStatus('üîÑ Generating true interactive fillable PDF...', 'info');

             try {
                 const pdfDoc = await PDFLib.PDFDocument.create();
                 const form = pdfDoc.getForm();
                 const page = pdfDoc.addPage([595, 842]); // A4 size
                 
                 // Add fonts
                 const titleFont = await pdfDoc.embedFont(PDFLib.StandardFonts.HelveticaBold);
                 const regularFont = await pdfDoc.embedFont(PDFLib.StandardFonts.Helvetica);
                 
                 // Try to add logo
                 try {
                     const logoUrl = '/public/LEVANTE/Levante_Logo.png';
                     const response = await fetch(logoUrl);
                     if (response.ok) {
                         const logoBytes = await response.arrayBuffer();
                         const logoImage = await pdfDoc.embedPng(logoBytes);
                         page.drawImage(logoImage, { x: 20, y: 790, width: 60, height: 40 });
                     }
                 } catch (error) {
                     console.warn('Could not add logo to PDF:', error);
                 }

                 // Add title
                 page.drawText('Caregiver Survey', { x: 100, y: 800, size: 18, font: titleFont });

                 let currentY = 720; // Leave more space at top for better layout with footer
                 
                 // Add header form fields
                 page.drawText('Child\'s Name:', { x: 50, y: currentY, size: 12, font: titleFont });
                 const childNameField = form.createTextField('childName');
                 childNameField.addToPage(page, { 
                     x: 150, y: currentY - 5, width: 200, height: 20,
                     borderWidth: 1,
                     borderColor: PDFLib.rgb(0, 0, 0),
                     backgroundColor: PDFLib.rgb(1, 1, 1),
                     color: PDFLib.rgb(0, 0, 0)
                 });
                 childNameField.setText('');
                 currentY -= 30;
                 
                 page.drawText('Caregiver\'s Name:', { x: 50, y: currentY, size: 12, font: titleFont });
                 const caregiverNameField = form.createTextField('caregiverName');
                 caregiverNameField.addToPage(page, { 
                     x: 150, y: currentY - 5, width: 200, height: 20,
                     borderWidth: 1,
                     borderColor: PDFLib.rgb(0, 0, 0),
                     backgroundColor: PDFLib.rgb(1, 1, 1),
                     color: PDFLib.rgb(0, 0, 0)
                 });
                 caregiverNameField.setText('');
                 currentY -= 30;
                 
                 page.drawText('Site and/or School:', { x: 50, y: currentY, size: 12, font: titleFont });
                 const siteSchoolField = form.createTextField('siteSchool');
                 siteSchoolField.addToPage(page, { 
                     x: 150, y: currentY - 5, width: 200, height: 20,
                     borderWidth: 1,
                     borderColor: PDFLib.rgb(0, 0, 0),
                     backgroundColor: PDFLib.rgb(1, 1, 1),
                     color: PDFLib.rgb(0, 0, 0)
                 });
                 siteSchoolField.setText('');
                 currentY -= 30;
                 
                 page.drawText('Date Completed:', { x: 50, y: currentY, size: 12, font: titleFont });
                 const dateField = form.createTextField('dateCompleted');
                 dateField.addToPage(page, { 
                     x: 150, y: currentY - 5, width: 200, height: 20,
                     borderWidth: 1,
                     borderColor: PDFLib.rgb(0, 0, 0),
                     backgroundColor: PDFLib.rgb(1, 1, 1),
                     color: PDFLib.rgb(0, 0, 0)
                 });
                 dateField.setText('');
                 currentY -= 50;

                 // Process all survey pages
                 let allElements = [];
                 if (surveyData.pages && surveyData.pages.length > 0) {
                     surveyData.pages.forEach(page => {
                         if (page.elements && page.elements.length > 0) {
                             allElements = allElements.concat(page.elements);
                         }
                     });
                 } else if (surveyData.elements) {
                     allElements = surveyData.elements;
                 }

                 const expandElements = (elements) => {
                     const expandedQuestions = [];
                     elements.forEach(element => {
                         if (element.type === 'html') {
                             // HTML elements often contain instructions - keep them for instruction extraction
                             expandedQuestions.push(element);
                         } else if (element.type === 'panel' && element.elements) {
                             // Add panel as section header if it has a title or description
                             if (element.title || element.description) {
                                 expandedQuestions.push({
                                     type: 'panel-header',
                                     title: element.title,
                                     description: element.description,
                                     name: element.name || 'panel'
                                 });
                             }
                             // Expand panel elements
                             expandedQuestions.push(...expandElements(element.elements));
                         } else if (element.type === 'matrix') {
                             // Expand matrix questions - each row becomes a separate question
                             if (element.rows && element.rows.length > 0) {
                                 element.rows.forEach(row => {
                                     const rowQuestion = {
                                         ...element,
                                         name: `${element.name}_${row.value}`,
                                         title: extractText(row.text) || row.value,
                                         type: 'matrix-row',
                                         choices: element.columns ? element.columns.map(col => ({
                                             value: col.value,
                                             text: extractText(col.text) || col.value
                                         })) : []
                                     };
                                     expandedQuestions.push(rowQuestion);
                                 });
                             } else {
                                 // Fallback if no rows
                                 expandedQuestions.push(element);
                             }
                         } else {
                             // Regular question
                             expandedQuestions.push(element);
                         }
                     });
                     return expandedQuestions;
                 };

                 const expandedElements = expandElements(allElements);
                 let questionCount = 0;
                 
                 for (const element of expandedElements) {
                     questionCount++;
                     
                     // Calculate space needed for this question
                     const spaceNeeded = calculateQuestionSpace(element);
                     
                     // Add new page if question won't fit
                     if (currentY - spaceNeeded < 80) {  // 80 units minimum bottom margin for footer
                         const newPage = pdfDoc.addPage([595, 842]);
                         currentY = 720; // Consistent with first page
                         // Add logo to new page
                         try {
                             const logoUrl = '/public/LEVANTE/Levante_Logo.png';
                             const response = await fetch(logoUrl);
                             if (response.ok) {
                                 const logoBytes = await response.arrayBuffer();
                                 const logoImage = await pdfDoc.embedPng(logoBytes);
                                 newPage.drawImage(logoImage, { x: 20, y: 790, width: 60, height: 40 });
                             }
                         } catch (error) {
                             console.warn('Could not add logo to new page:', error);
                         }
                     }
                     
                     currentY = await addInteractiveQuestionToPdf(pdfDoc, form, element, currentY, questionCount);
                 }

                 // Add footers to all pages
                 await addFootersToAllPages(pdfDoc);

                 const pdfBytes = await pdfDoc.save();
                 const blob = new Blob([pdfBytes], { type: 'application/pdf' });
                 const url = URL.createObjectURL(blob);
                 const a = document.createElement('a');
                 a.href = url;
                 a.download = 'caregiver_survey_interactive_fillable.pdf';
                 document.body.appendChild(a);
                 a.click();
                 document.body.removeChild(a);
                 URL.revokeObjectURL(url);
                 showStatus('‚úÖ Interactive fillable PDF generated and downloaded successfully!', 'success');

             } catch (error) {
                 console.error('Error generating fillable PDF:', error);
                 showStatus(`‚ùå Error generating fillable PDF: ${error.message}`, 'error');
             }
         }

                          async function addInteractiveQuestionToPdf(pdfDoc, form, element, startY, questionNumber) {
             const page = pdfDoc.getPages()[pdfDoc.getPageCount() - 1];
             let currentY = startY;

             // Handle HTML instruction elements
             if (element.type === 'html') {
                 if (element.html) {
                     const instructionText = parseHtmlToText(element.html);
                     if (instructionText) {
                         const titleFont = await pdfDoc.embedFont(PDFLib.StandardFonts.Helvetica);
                         const instructionLines = wrapText(instructionText, 70);
                         instructionLines.forEach(line => {
                             page.drawText(line, { x: 50, y: currentY, size: 10, font: titleFont, color: PDFLib.rgb(0.3, 0.3, 0.3) });
                             currentY -= 12;
                         });
                         currentY -= 10; // Extra spacing after instructions
                     }
                 }
                 return currentY;
             }
             
             // Handle panel headers (section dividers)
             if (element.type === 'panel-header') {
                 currentY -= 10; // Extra space before section
                 
                 if (element.title) {
                     const sectionTitle = extractText(element.title);
                     const sectionFont = await pdfDoc.embedFont(PDFLib.StandardFonts.HelveticaBold);
                     currentY = drawWrappedText(page, sectionTitle, 50, currentY, sectionFont, 14, PDFLib.rgb(0, 0, 0), 500);
                 }
                 
                 if (element.description) {
                     const sectionDescription = parseHtmlToText(element.description);
                     if (sectionDescription) {
                         const descFont = await pdfDoc.embedFont(PDFLib.StandardFonts.Helvetica);
                         currentY = drawWrappedText(page, sectionDescription, 70, currentY, descFont, 10, PDFLib.rgb(0.4, 0.4, 0.4), 480);
                     }
                 }
                 
                 currentY -= 10; // Extra space after section
                 return currentY;
             }

             const questionTitle = getElementTitle(element);
             const fieldName = element.name ? element.name.replace(/[^a-zA-Z0-9_]/g, '_') : `question_${questionNumber}`;

             const titleFont = await pdfDoc.embedFont(PDFLib.StandardFonts.HelveticaBold);
             const regularFont = await pdfDoc.embedFont(PDFLib.StandardFonts.Helvetica);

             // Extract and display instructions/descriptions for all question types
             let instructions = '';
             if (element.description) {
                 instructions = parseHtmlToText(element.description);
             } else if (element.descriptionHtml) {
                 instructions = parseHtmlToText(element.descriptionHtml);
             } else if (element.html) {
                 instructions = parseHtmlToText(element.html);
             }

             if (element.type === 'boolean') {
                 // Draw question title with wrapping
                 currentY = drawWrappedText(page, `${questionNumber}. ${questionTitle}`, 50, currentY, titleFont, 11, PDFLib.rgb(0, 0, 0), 500);
                 
                 // Display instructions if available
                 if (instructions) {
                     const instructionLines = wrapText(instructions, 70);
                     instructionLines.forEach(line => {
                         page.drawText(line, { x: 70, y: currentY, size: 9, font: regularFont, color: PDFLib.rgb(0.4, 0.4, 0.4) });
                         currentY -= 12;
                     });
                     currentY -= 5;
                 } else {
                     currentY -= 5;
                 }

                 // Create radio group for yes/no with better configuration
                 const radioGroup = form.createRadioGroup(fieldName);
                 const trueLabel = extractText(element.labelTrue) || 'Yes';
                 const falseLabel = extractText(element.labelFalse) || 'No';
                 
                 // Yes option - clear positioning without overlap
                 page.drawText(`${trueLabel}`, { x: 90, y: currentY, size: 10, font: regularFont });
                 radioGroup.addOptionToPage('true', page, { 
                     x: 70, y: currentY - 2, width: 15, height: 15,
                     borderWidth: 1,
                     borderColor: PDFLib.rgb(0, 0, 0)
                 });
                 
                 // No option - clear positioning without overlap  
                 page.drawText(`${falseLabel}`, { x: 170, y: currentY, size: 10, font: regularFont });
                 radioGroup.addOptionToPage('false', page, { 
                     x: 150, y: currentY - 2, width: 15, height: 15,
                     borderWidth: 1,
                     borderColor: PDFLib.rgb(0, 0, 0)
                 });
                 
                 currentY -= 35;

             } else if (element.type === 'radiogroup') {
                 // Draw question title with wrapping
                 currentY = drawWrappedText(page, `${questionNumber}. ${questionTitle}`, 50, currentY, titleFont, 11, PDFLib.rgb(0, 0, 0), 500);
                 
                 // Display instructions if available
                 if (instructions) {
                     const instructionLines = wrapText(instructions, 70);
                     instructionLines.forEach(line => {
                         page.drawText(line, { x: 70, y: currentY, size: 9, font: regularFont, color: PDFLib.rgb(0.4, 0.4, 0.4) });
                         currentY -= 12;
                     });
                     currentY -= 5;
                 } else {
                     currentY -= 5;
                 }

                 // Create radio group
                 const radioGroup = form.createRadioGroup(fieldName);
                 
                 if (element.choices && element.choices.length > 0) {
                     element.choices.forEach((choice, index) => {
                         let choiceText = '';
                         let choiceValue = '';
                         
                         if (typeof choice === 'string') {
                             choiceText = choice;
                             choiceValue = choice;
                         } else if (typeof choice === 'object' && choice) {
                             choiceText = extractText(choice.text) || extractText(choice.title) || extractText(choice) || choice.value || String(choice);
                             choiceValue = choice.value || choiceText || String(choice);
                         } else {
                             choiceText = String(choice);
                             choiceValue = String(choice);
                         }
                         
                         page.drawText(`${choiceText}`, { x: 90, y: currentY, size: 10, font: regularFont });
                         radioGroup.addOptionToPage(choiceValue, page, { 
                             x: 70, y: currentY - 2, width: 15, height: 15,
                             borderWidth: 1,
                             borderColor: PDFLib.rgb(0, 0, 0),
                             backgroundColor: PDFLib.rgb(1, 1, 1)
                         });
                         currentY -= 25;
                     });
                 }
                 currentY -= 10;

             } else if (element.type === 'checkbox') {
                 // Draw question title with wrapping
                 currentY = drawWrappedText(page, `${questionNumber}. ${questionTitle}`, 50, currentY, titleFont, 11, PDFLib.rgb(0, 0, 0), 500);
                 
                 // Display instructions if available
                 if (instructions) {
                     const instructionLines = wrapText(instructions, 70);
                     instructionLines.forEach(line => {
                         page.drawText(line, { x: 70, y: currentY, size: 9, font: regularFont, color: PDFLib.rgb(0.4, 0.4, 0.4) });
                         currentY -= 12;
                     });
                     currentY -= 5;
                 } else {
                     currentY -= 5;
                 }

                 if (element.choices && element.choices.length > 0) {
                     element.choices.forEach((choice, index) => {
                         let choiceText = '';
                         let choiceValue = '';
                         
                         if (typeof choice === 'string') {
                             choiceText = choice;
                             choiceValue = choice;
                         } else if (typeof choice === 'object' && choice) {
                             choiceText = extractText(choice.text) || extractText(choice.title) || extractText(choice) || choice.value || String(choice);
                             choiceValue = choice.value || choiceText || String(choice);
                         } else {
                             choiceText = String(choice);
                             choiceValue = String(choice);
                         }
                         
                         // Create individual checkbox for each choice with proper styling
                         const checkbox = form.createCheckBox(`${fieldName}_${index}`);
                         page.drawText(`${choiceText}`, { x: 90, y: currentY, size: 10, font: regularFont });
                         checkbox.addToPage(page, { 
                             x: 70, y: currentY - 2, width: 15, height: 15,
                             borderWidth: 1,
                             borderColor: PDFLib.rgb(0, 0, 0),
                             backgroundColor: PDFLib.rgb(1, 1, 1)
                         });
                         currentY -= 25;
                     });
                 }
                 currentY -= 10;

             } else if (element.type === 'matrix-row') {
                 // Draw question title with wrapping
                 currentY = drawWrappedText(page, `${questionNumber}. ${questionTitle}`, 50, currentY, titleFont, 11, PDFLib.rgb(0, 0, 0), 500);
                 
                 // Display instructions if available
                 if (instructions) {
                     const instructionLines = wrapText(instructions, 70);
                     instructionLines.forEach(line => {
                         page.drawText(line, { x: 70, y: currentY, size: 9, font: regularFont, color: PDFLib.rgb(0.4, 0.4, 0.4) });
                         currentY -= 12;
                     });
                     currentY -= 5;
                 } else {
                     currentY -= 5;
                 }

                 // Create radio group for matrix row - stack vertically for better fit
                 const radioGroup = form.createRadioGroup(fieldName);
                 
                 if (element.choices && element.choices.length > 0) {
                     element.choices.forEach((choice, index) => {
                         let choiceText = '';
                         let choiceValue = '';
                         
                         if (typeof choice === 'string') {
                             choiceText = choice;
                             choiceValue = choice;
                         } else if (typeof choice === 'object' && choice) {
                             choiceText = extractText(choice.text) || extractText(choice.title) || extractText(choice) || choice.value || String(choice);
                             choiceValue = choice.value || choiceText || String(choice);
                         } else {
                             choiceText = String(choice);
                             choiceValue = String(choice);
                         }
                         
                         // Stack vertically instead of horizontally to fit on screen
                         page.drawText(`${choiceText}`, { x: 90, y: currentY, size: 10, font: regularFont });
                         radioGroup.addOptionToPage(choiceValue, page, { 
                             x: 70, y: currentY - 2, width: 15, height: 15,
                             borderWidth: 1,
                             borderColor: PDFLib.rgb(0, 0, 0),
                             backgroundColor: PDFLib.rgb(1, 1, 1)
                         });
                         currentY -= 25; // Move down for next option
                     });
                 }
                 currentY -= 10;

             } else if (element.type === 'text' && element.inputType === 'range') {
                 // Draw question title with wrapping
                 currentY = drawWrappedText(page, `${questionNumber}. ${questionTitle}`, 50, currentY, titleFont, 11, PDFLib.rgb(0, 0, 0), 500);
                 
                 // Parse HTML instructions for timeline questions
                 let instructions = '';
                 if (element.html) {
                     instructions = parseHtmlToText(element.html);
                 } else if (element.description) {
                     instructions = parseHtmlToText(element.description);
                 } else if (element.descriptionHtml) {
                     instructions = parseHtmlToText(element.descriptionHtml);
                 }
                 
                 // If still no instructions, provide default for timeline questions
                 if (!instructions) {
                     instructions = 'Please indicate your response on the timeline below.';
                 }
                 
                 // Display instructions if available (wrap text if needed)
                 if (instructions) {
                     const instructionLines = wrapText(instructions, 70); // Wrap at 70 characters
                     instructionLines.forEach(line => {
                         page.drawText(line, { x: 70, y: currentY, size: 9, font: regularFont });
                         currentY -= 12;
                     });
                     currentY -= 10;
                 }
                 
                 // Draw a visual timeline/scale
                 const minVal = element.min || 0;
                 const maxVal = element.max || 10;
                 const scaleWidth = 300;
                 const scaleStartX = 70;
                 
                 // Draw timeline instruction
                 page.drawText(`Mark your answer on the scale below (${minVal} to ${maxVal}):`, { x: 70, y: currentY, size: 10, font: regularFont });
                 currentY -= 20;
                 
                 // Draw the timeline scale
                 page.drawLine({
                     start: { x: scaleStartX, y: currentY },
                     end: { x: scaleStartX + scaleWidth, y: currentY },
                     thickness: 2
                 });
                 
                 // Draw tick marks and labels
                 const numTicks = Math.min(maxVal - minVal + 1, 11); // Max 11 ticks
                 for (let i = 0; i < numTicks; i++) {
                     const tickX = scaleStartX + (i * scaleWidth / (numTicks - 1));
                     const tickValue = minVal + (i * (maxVal - minVal) / (numTicks - 1));
                     
                     // Draw tick mark
                     page.drawLine({
                         start: { x: tickX, y: currentY - 5 },
                         end: { x: tickX, y: currentY + 5 },
                         thickness: 1
                     });
                     
                     // Draw tick label
                     page.drawText(Math.round(tickValue).toString(), { 
                         x: tickX - 5, 
                         y: currentY - 15, 
                         size: 8, 
                         font: regularFont 
                     });
                 }
                 
                 // Create text field for numerical answer
                 page.drawText(`Your answer:`, { x: 70, y: currentY - 35, size: 10, font: regularFont });
                 const textField = form.createTextField(fieldName);
                 textField.addToPage(page, { 
                     x: 150, y: currentY - 40, width: 60, height: 20,
                     borderWidth: 1,
                     borderColor: PDFLib.rgb(0, 0, 0),
                     backgroundColor: PDFLib.rgb(1, 1, 1),
                     color: PDFLib.rgb(0, 0, 0)
                 });
                 textField.setText('');
                 
                 currentY -= 60;

             } else if (element.type === 'comment') {
                 // Draw question title with wrapping
                 currentY = drawWrappedText(page, `${questionNumber}. ${questionTitle}`, 50, currentY, titleFont, 11, PDFLib.rgb(0, 0, 0), 500);
                 
                 // Display instructions if available
                 if (instructions) {
                     const instructionLines = wrapText(instructions, 70);
                     instructionLines.forEach(line => {
                         page.drawText(line, { x: 70, y: currentY, size: 9, font: regularFont, color: PDFLib.rgb(0.4, 0.4, 0.4) });
                         currentY -= 12;
                     });
                     currentY -= 5;
                 } else {
                     currentY -= 5;
                 }
                 
                 // Create multiline text field
                 const textField = form.createTextField(fieldName);
                 textField.setMultiline(true);
                 textField.addToPage(page, { 
                     x: 70, y: currentY - 40, width: 400, height: 60,
                     borderWidth: 1,
                     borderColor: PDFLib.rgb(0, 0, 0),
                     backgroundColor: PDFLib.rgb(1, 1, 1),
                     color: PDFLib.rgb(0, 0, 0)
                 });
                 textField.setText('');
                 currentY -= 70;

             } else if (element.type === 'text') {
                 // Draw question title with wrapping
                 currentY = drawWrappedText(page, `${questionNumber}. ${questionTitle}`, 50, currentY, titleFont, 11, PDFLib.rgb(0, 0, 0), 500);
                 
                 // Display instructions if available
                 if (instructions) {
                     const instructionLines = wrapText(instructions, 70);
                     instructionLines.forEach(line => {
                         page.drawText(line, { x: 70, y: currentY, size: 9, font: regularFont, color: PDFLib.rgb(0.4, 0.4, 0.4) });
                         currentY -= 12;
                     });
                     currentY -= 5;
                 } else {
                     currentY -= 5;
                 }
                 
                 // Create text field
                 const textField = form.createTextField(fieldName);
                 textField.addToPage(page, { 
                     x: 70, y: currentY - 5, width: 300, height: 20,
                     borderWidth: 1,
                     borderColor: PDFLib.rgb(0, 0, 0),
                     backgroundColor: PDFLib.rgb(1, 1, 1),
                     color: PDFLib.rgb(0, 0, 0)
                 });
                 textField.setText('');
                 currentY -= 35;
             }
             
             return currentY;
         }

        // Initialize
        showStatus('üëã Ready to test! Click "Analyze Survey" to start.', 'info');
        document.getElementById('generateBtn').disabled = true;
        document.getElementById('generateOptionsBtn').disabled = true;
        document.getElementById('generateFillableBtn').disabled = true;
        document.getElementById('generateFillableOptionsBtn').disabled = true;
        document.getElementById('htmlFormBtn').disabled = true;
        document.getElementById('trueFillableBtn').disabled = true;
    </script>
</body>
</html> 