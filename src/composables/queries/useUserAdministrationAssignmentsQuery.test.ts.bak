import { ref, nextTick, type Ref } from 'vue';
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import {
  QueryClient,
  VueQueryPlugin,
  useQuery,
  // Keep UseQueryOptions commented out
  // type UseQueryOptions,
} from '@tanstack/vue-query';
import { nanoid } from 'nanoid';
import { withSetup } from '@/test-support/withSetup';
import { fetchDocById } from '@/helpers/query/utils'; // Corrected import name
import useUserAdministrationAssignmentsQuery from './useUserAdministrationAssignmentsQuery';

// --- Mocks ---
const mockFetchDocById = vi.fn().mockResolvedValue(null); // Mock fetchDocById
const mockUseQuery = vi.fn(); // Declare before vi.mocks

vi.mock('@/helpers/query/utils', () => ({
  fetchDocById: mockFetchDocById,
}));

vi.mock('@tanstack/vue-query', async (importOriginal) => {
  const original = await importOriginal<typeof import('@tanstack/vue-query')>();
  mockUseQuery.mockImplementation(() => ({ 
    data: ref(null), 
    isLoading: ref(false), 
    isError: ref(false), 
    error: ref(null) 
  })); 
  return {
    useQuery: mockUseQuery,
    QueryClient: original.QueryClient,
    VueQueryPlugin: original.VueQueryPlugin,
  };
});

// --- Types ---
// Placeholder type for the data returned by the query
interface Assignment {
  id: string;
  // Add other relevant properties if known
}

// --- Tests ---
describe('useUserAdministrationAssignmentsQuery', () => {
  let queryClient: QueryClient;

  beforeEach(() => {
    queryClient = new QueryClient();
    vi.clearAllMocks();
  });

  afterEach(() => {
    queryClient?.clear();
  });

  it('should call query with correct parameters', () => {
    // Pass plain strings or Refs based on composable definition
    // Assuming composable accepts plain strings for IDs
    const mockUserId: Ref<string | null> = ref(nanoid());
    const mockAdministrationId: Ref<string | null> = ref(nanoid());

    withSetup(() => useUserAdministrationAssignmentsQuery(mockUserId, mockAdministrationId), {
      plugins: [[VueQueryPlugin, { queryClient }]],
    });

    expect(mockUseQuery).toHaveBeenCalledWith({
      queryKey: ['user-administration-assignments', mockUserId, mockAdministrationId],
      queryFn: expect.any(Function),
      enabled: expect.objectContaining({ value: true }), // Enabled because both IDs are present
    });

    // Assuming queryFn calls fetchDocById
    expect(mockFetchDocById).toHaveBeenCalledWith(
        'users', 
        `${mockUserId.value}/assignments/${mockAdministrationId.value}`
    );
  });

  it('should correctly control the enabled state via passed query options', async () => {
    const mockUserId: Ref<string | null> = ref(nanoid());
    const mockAdministrationId: Ref<string | null> = ref(nanoid());
    const enableQuery = ref(false);
    const queryOptions = { 
        queryKey: ['user-admin-assignments', mockUserId, mockAdministrationId],
        enabled: enableQuery 
    } as any;

    withSetup(() => useUserAdministrationAssignmentsQuery(mockUserId, mockAdministrationId, queryOptions), {
      plugins: [[VueQueryPlugin, { queryClient }]],
    });

    expect(mockUseQuery).toHaveBeenCalledWith({
      queryKey: ['user-administration-assignments', mockUserId, mockAdministrationId],
      queryFn: expect.any(Function),
      enabled: expect.objectContaining({ value: false }), // Initially false due to ref
    });
    expect(mockFetchDocById).not.toHaveBeenCalled();

    enableQuery.value = true;
    await nextTick();

    // Expect fetch to be called after ref change
    expect(mockFetchDocById).toHaveBeenCalledWith(
        'users', 
        `${mockUserId.value}/assignments/${mockAdministrationId.value}`
    );
  });

  it('should only fetch data if both params are set (non-null)', async () => {
    const mockUserId: Ref<string | null> = ref(null);
    const mockAdministrationId: Ref<string | null> = ref(null);
    const queryOptions = { 
        queryKey: ['user-admin-assignments', mockUserId, mockAdministrationId],
        enabled: true 
    } as any;

    withSetup(() => useUserAdministrationAssignmentsQuery(mockUserId, mockAdministrationId, queryOptions), {
      plugins: [[VueQueryPlugin, { queryClient }]],
    });

    expect(mockUseQuery).toHaveBeenCalledWith({
      queryKey: ['user-administration-assignments', mockUserId, mockAdministrationId],
      queryFn: expect.any(Function),
      enabled: expect.objectContaining({ value: false }), // False because userId is null
    });
    expect(mockFetchDocById).not.toHaveBeenCalled();

    // Set userId
    mockUserId.value = nanoid();
    await nextTick();
    expect(mockFetchDocById).not.toHaveBeenCalled(); // Still false because adminId is null

    // Set adminId
    mockAdministrationId.value = nanoid();
    await nextTick();

    // Now expect fetch to be called
    expect(mockFetchDocById).toHaveBeenCalledWith(
        'users', 
        `${mockUserId.value}/assignments/${mockAdministrationId.value}`
    );
  });

  it('should not let queryOptions override the internally computed value (missing userId)', async () => {
    const mockUserId: Ref<string | null> = ref(null);
    const mockAdministrationId: Ref<string | null> = ref(nanoid()); // Admin ID is present
    const queryOptions = { 
        queryKey: ['user-admin-assignments', mockUserId, mockAdministrationId],
        enabled: true 
    } as any;

    withSetup(() => useUserAdministrationAssignmentsQuery(mockUserId, mockAdministrationId, queryOptions), {
      plugins: [[VueQueryPlugin, { queryClient }]],
    });

    expect(mockUseQuery).toHaveBeenCalledWith({
      queryKey: ['user-administration-assignments', mockUserId, mockAdministrationId],
      queryFn: expect.any(Function),
      enabled: expect.objectContaining({ value: false }), // Stays false because userId is null
    });
    expect(mockFetchDocById).not.toHaveBeenCalled();
  });
  
  it('should not let queryOptions override the internally computed value (missing adminId)', async () => {
    const mockUserId: Ref<string | null> = ref(nanoid()); // User ID is present
    const mockAdministrationId: Ref<string | null> = ref(null);
    const queryOptions = { 
        queryKey: ['user-admin-assignments', mockUserId, mockAdministrationId],
        enabled: true 
    } as any;

    withSetup(() => useUserAdministrationAssignmentsQuery(mockUserId, mockAdministrationId, queryOptions), {
      plugins: [[VueQueryPlugin, { queryClient }]],
    });

    expect(mockUseQuery).toHaveBeenCalledWith({
      queryKey: ['user-administration-assignments', mockUserId, mockAdministrationId],
      queryFn: expect.any(Function),
      enabled: expect.objectContaining({ value: false }), // Stays false because adminId is null
    });
    expect(mockFetchDocById).not.toHaveBeenCalled();
  });

  it('should only fetch data if the userId and administrationId are available', async () => {
    const mockUserId: Ref<string | null> = ref(null); // Start with null
    const mockAdministrationId: Ref<string | null> = ref(nanoid());
    const queryOptions = { 
        queryKey: ['user-admin-assignments', mockUserId, mockAdministrationId],
        enabled: true 
    } as any;

    withSetup(() => useUserAdministrationAssignmentsQuery(mockUserId, mockAdministrationId, queryOptions), {
      plugins: [[VueQueryPlugin, { queryClient }]],
    });

    expect(mockUseQuery).toHaveBeenCalledWith({
      queryKey: ['user-administration-assignments', mockUserId, mockAdministrationId],
      queryFn: expect.any(Function),
      enabled: expect.objectContaining({ value: false }), // False because userId is null
    });
    expect(mockFetchDocById).not.toHaveBeenCalled();

    // Set userId
    mockUserId.value = nanoid();
    await nextTick();
    expect(mockFetchDocById).not.toHaveBeenCalled(); // Still false because adminId is null

    // Set adminId
    mockAdministrationId.value = nanoid();
    await nextTick();

    // Now expect fetch to be called
    expect(mockFetchDocById).toHaveBeenCalledWith(
        'users', 
        `${mockUserId.value}/assignments/${mockAdministrationId.value}`
    );
  });
}); 